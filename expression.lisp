(in-package :lcc)

(defun print-expr (spec &optional (lvl 0))
  (format t
    "~A~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~S ~;~*~]~%"
	  (indent lvl) (null (const spec)) (const spec) (null (typeof spec)) (typeof spec)
	  (null (modifier spec)) (modifier spec) (null (const-ptr spec)) (const-ptr spec)
	  (null (array-def spec)) (array-def spec) (null (default spec)) (default spec))
  (let ((body (slot-value spec 'body)))
    (when body
      (dolist (form body)
	(print-expr form (+ 1 lvl))))))

(defun type-spec-string< (spec)
  (format nil "~:[~A ~;~*~]~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]"
	  (null (const spec)) (const spec) (typeof spec) (null (modifier spec)) (modifier spec)
	  (null (const-ptr spec)) (const-ptr spec) (null (array-def spec)) (array-def spec)))

(defun has-ctor-of (to-spec from-spec globals)
  (let ((to-type-spec (gethash (typeof to-spec) globals)))
    (when to-type-spec
      (let ((ctors (gethash (user-symbol "new") (slot-value to-type-spec 'inners))))
	(dolist (ctor ctors)
	  (when (param-spec-match ctor from-spec globals) (return-from has-ctor-of (values t ctor)))))
      (let ((ctors (gethash (name to-type-spec) (slot-value to-type-spec 'inners))))	
	(dolist (ctor ctors)
	  (let ((params (slot-value ctor 'params)))
	    (when (= (hash-table-count params) 1)
	      (maphash #'(lambda (k v)
			   (when (param-spec-match v from-spec globals nil)
			     (return-from has-ctor-of (values t ctor))))
		       params))))))))
	      
(defun param-spec-match (to-spec from-spec globals &optional (recursive t))
  (let ((matched nil))
    (if (and (key-eq (typeof to-spec) '|void|) (key-eq (modifier to-spec) '|*|)
	     (key-eq (modifier from-spec) '|*|))
	(setq matched t)
      (if (and (key-eq (modifier to-spec) '|*|) (key-eq (typeof from-spec) '|size_t|))
	  (setq matched t)
	(if (and (key-eq (modifier to-spec) '|*|) (key-eq (modifier from-spec) '|*|)
		 (null (const to-spec)) (const from-spec)) nil
	  (if (not (equal (typeof to-spec) (typeof from-spec))) nil
	    (if (not (eql (modifier to-spec) (modifier from-spec))) nil
	      (setq matched t))))))
    (when (and (not matched) recursive)
      (multiple-value-bind (has implicit-spec)
	(has-ctor-of to-spec from-spec globals)
	(when has
	  (setq matched t))))
    matched))

(defun params-spec-match (to-spec from-spec globals)
  (let ((counter 0)
	(matched t))
    (maphash #'(lambda (p-name p-spec)
		 (unless (eql p-name (user-symbol "***"))
		   (unless (param-spec-match p-spec (nth counter (slot-value from-spec 'body)) globals)
		     (setq matched nil)))
		 (incf counter))
	     (slot-value to-spec 'params))
    matched))

(defun params-spec-method-match (to-spec from-spec globals)
  (let ((counter 1)
	(matched t))
    (maphash #'(lambda (p-name p-spec)
		 (unless (eql p-name (user-symbol "***"))
		   (unless (param-spec-match p-spec (nth counter (slot-value from-spec 'body)) globals)
		     (setq matched nil)))
		 (incf counter))
	     (slot-value to-spec 'params))
    matched))

(defun specify-->-form (func args expr globals)
  (unless (= (length expr) 3) (error (format nil "invalid use of ~A" func)))
  (let ((spec nil)
	(type-spec (gethash (car args) globals)))
    (when (null type-spec) (error (format nil "undefined variable ~A" (car args))))
    (setq type-spec (gethash (typeof type-spec) globals))
    (let ((member-spec (gethash (nth 1 args) (slot-value type-spec 'inners))))
      (when (null member-spec)
	(error (format nil "undefined member ~A for variable ~A of type ~A"
		       (nth 1 args) (nth 0 args) (default type-spec))))
      (setq spec (copy-specifier member-spec))
      (setf (default spec) expr)
      (specify-args spec args globals))
    spec))

(defun specify-cast-form (func args expr globals)
  (unless (= (length args) 2) (error (format nil "cast takes a type and a value ~A" args)))
  (let ((spec nil))
    (multiple-value-bind (const typeof modifier const-ptr name array-def)
      (specify-type< (car args) globals)
      (setq spec (make-specifier nil '|@EXPR| const typeof modifier const-ptr array-def expr nil)))
    (specify-args spec (cdr args) globals)
    spec))

(defun specify-sizeof-form (func args expr globals)
  (when (< (length args) 1) (error (format nil "sizeof takes a type or a value ~A" args)))
  (let ((spec nil))
    (setq spec (make-specifier nil '|@EXPR| nil
			       (user-symbol "size_t")
			       nil nil nil expr nil))
    (multiple-value-bind (const typeof modifier const-ptr name array-def)
      (specify-type< args globals)
      (unless (gethash typeof globals) (error (format nil "sizeof undefined type ~A" typeof))))
    spec))

(defun specify-set-form (func args expr globals)
  (unless (= (length args) 2) (error (format nil "could not set more than one value in ~A" expr)))
  (let((spec nil))
    (setq spec (make-specifier nil '|@EXPR| nil (user-symbol "void") nil nil nil expr nil))
    (specify-args spec args globals)
    (unless (param-spec-match (nth 0 (slot-value spec 'body)) (nth 1 (slot-value spec 'body)) globals)
      (error (format nil "set sides are not matched ~A" expr)))
    spec))

(defun specify-return-form (func args expr globals)
  (when (> (length args) 1) (error (format nil "could not return more than one value in ~A" expr)))
  (let ((spec nil))
    (setq spec (make-specifier nil '|@EXPR| nil (user-symbol "void") nil nil nil expr nil))
    (specify-args spec args globals)
    (let ((current-function-spec (gethash '|*function*| globals)))
      (unless (param-spec-match current-function-spec (nth 0 (slot-value spec 'body)) globals)
	(error (format nil "return value ~A is not match with function ~A return type ~A"
		       (type-spec-string< (nth 0 (slot-value spec 'body)))
		       (name current-function-spec)
		       (type-spec-string< current-function-spec)))))
    spec))

(defun specify-nth-form (func args expr globals)
  (unless (= (length args) 2) (error (format nil "nth takes an index of an array ~A" expr)))
  (let ((spec nil)
	(tmp-spec (make-specifier nil '|@EXPR| nil (user-symbol "void") nil nil nil expr nil)))
    (specify-args tmp-spec args globals)
    (setq spec (copy-specifier (nth 1 (slot-value tmp-spec 'body))))
    (setf (default spec) expr)
    (setf (slot-value spec 'body) (slot-value tmp-spec 'body))
    (setq tmp-spec (nth 1 (slot-value tmp-spec 'body)))
    (if (null (modifier tmp-spec))
	(progn
	  (when (null (array-def spec)) (error (format nil "it is not an array ~A" expr)))
	  (setf (array-def spec) nil))
      (if (key-eq (modifier tmp-spec) '|*|)
	  (if (null (array-def spec))
	      (setf (modifier spec) nil)
	    (setf (array-def spec) nil))
	(if (key-eq (modifier tmp-spec) '|**|)
	    (if (null (array-def spec))
		(setf (modifier spec) (user-symbol "*"))
	      (error (format nil "it is not an valid array ~A" expr)))
	  (error (format nil "it is not an valid array ~A" expr)))))
    spec))

(defun specify-new-form (func args expr globals)
  (when (< (length args) 1) (error (format nil "new clause needs a class ~A" expr)))
  (let ((spec nil)
	(class-spec (gethash (car args) globals)))
    (when (null class-spec) (error (format nil "undefined class ~A" expr)))
    (let ((tmp-spec (make-specifier nil '|@EXPR| nil (user-symbol "void") nil nil nil expr nil))
	  (overloads (gethash func (slot-value class-spec 'inners)))
	  (ctor-found nil))
      (specify-args tmp-spec (cdr args) globals)
      (unless (null overloads)
	(dolist (ctor-spec overloads)
	  (when (params-spec-match ctor-spec tmp-spec globals)
	    (setq ctor-found t)
	    (setq spec (copy-specifier ctor-spec))
	    (setq expr (cons (user-symbol (method-name< (default class-spec)
					    (name ctor-spec))) (nthcdr 2 expr)))
	    (setf (default spec) expr)
	    (setf (slot-value spec 'body) (slot-value tmp-spec 'body)))))
      (unless ctor-found
	(error (format nil "parameters and arguments not matched with any constructors of ~A " (default class-spec))))
    spec)))

(defun specify-call-form (func args expr globals)
  (let ((spec nil)
	(method-found nil))
    (when (> (length args) 0)
      (progn
	(let ((tmp-spec (make-specifier nil '|@EXPR| nil (user-symbol "void") nil nil nil expr nil)))
	  (specify-args tmp-spec args globals)
	  (let* ((first-arg  (nth 0 (slot-value tmp-spec 'body)))
		 (first-spec nil))
	    (if (or (null (modifier first-arg)) (is-name func))
		(setq first-spec (gethash (typeof first-arg) globals))
	      (setq first-spec (gethash (user-symbol "size_t") globals)))
	    (if (null first-spec)
		(error (format nil "could not specify first argument of function ~A" func))
	      (let ((overloads (gethash (user-symbol (operator-c-name< func))
					(slot-value first-spec 'inners))))
		(when (null overloads)
		  (setq overloads (gethash func (slot-value first-spec 'inners))))
		(unless (null overloads)
		  (dolist (method-spec overloads)
		    (display "O1" overloads)
		    (print-specifier method-spec)
		    (print-specifier tmp-spec)
		    (when (params-spec-method-match method-spec tmp-spec globals)
		      (display "O2" overloads)
		      (setq method-found t)
		      (setq spec (copy-specifier method-spec))
		      (unless (eql (construct first-spec) '|@META|)
			(setq expr (cons (user-symbol (method-name< (default first-spec)
							(name method-spec))) (nthcdr 2 expr))))
		      (setf (default spec) expr)
		      (setf (slot-value spec 'body) (slot-value tmp-spec 'body)))))))))))
    (unless method-found
      (let ((func-spec (gethash func globals)))
	(when (null func-spec) (error (format nil "could not specify function or operator ~A" func)))
	(setq spec (copy-specifier func-spec))
	(setf (default spec) expr) 
	(specify-args spec args globals)
	(print-expr (nth 0 (slot-value spec 'body)))
	(unless (params-spec-match func-spec spec globals)
	  (print-expr (nth 0 (slot-value spec 'body)))
	  (error (format nil "parameters and arguments not matched when calling function ~A" func)))))
    spec))

(defun specify-args (func-spec args globals)
  (dolist (arg args)
    (setf (slot-value func-spec 'body)
	  (append (slot-value func-spec 'body) (list (specify-expr arg globals))))))

(defun specify-expr (expr globals)
  (let ((spec nil))
    (cond ((or (null expr) (key-eq '|nil| expr))
	   (setq spec (make-specifier nil '|@EXPR| nil
				      (user-symbol "size_t")
				      nil nil nil expr nil)))
	  ((numberp expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "int")
				      nil nil nil expr nil)))
	  ((unsigned-int-p expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "uint")
				      nil nil nil expr nil)))
	  ((long-p expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "long")
				      nil nil nil expr nil)))
	  ((unsigned-long-p expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "ulong")
				      nil nil nil expr nil)))
	  ((characterp expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "char")
				      nil nil nil expr nil)))
	  ((stringp expr)
	   (setq spec (make-specifier nil '|@EXPR|
				      (user-symbol "const")
				      (user-symbol "char")
				      (user-symbol "*")
				      nil nil expr nil)))
	  ((symbolp expr)
	   (let ((sym-spec (gethash expr globals)))
	     (if (null sym-spec)
		 (error (format nil "could not specify symbol ~A" expr))
	       (progn
		 (setq spec (copy-specifier sym-spec))
		 (setf (default spec) expr)))))
	  ((listp expr)
	   (progn
	     (let ((func (car expr))
		   (args (last expr (- (length expr) 1))))
	       (setq spec
		     (cond ((key-eq func '|->|)       (specify-->-form     func args expr globals))
			   ((key-eq func '|cast|)     (specify-cast-form   func args expr globals))
			   ((key-eq func '|sizeof|)   (specify-sizeof-form func args expr globals))
			   ((key-eq func '|set|)      (specify-set-form    func args expr globals))
			   ((key-eq func '|return|)   (specify-return-form func args expr globals))
			   ((key-eq func '|nth|)      (specify-nth-form    func args expr globals))
			   ((key-eq func '|new|)      (specify-new-form    func args expr globals))
			   (t                         (specify-call-form   func args expr globals)))))))
	  (t (error (format nil "could not specify expression ~A" expr))))
    (print-expr spec)
    spec))
