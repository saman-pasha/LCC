(in-package :lcc)

(defclass specifier ()
  ((name      :initarg :name :accessor name)
   (construct :initarg :construct :accessor construct)
   (const     :initarg :const :accessor const)
   (typeof    :initarg :typeof :accessor typeof)
   (modifier  :initarg :modifier :accessor modifier)
   (const-ptr :initarg :const-ptr :accessor const-ptr)
   (array-def :initarg :array-def :accessor array-def)
   (default   :initarg :default :accessor default)
   (attrs     :initarg :attrs :accessor attrs)
   (anonymous :initarg :anonymous :initform nil :accessor anonymous)
   (body      :initform nil)
   (params    :initform nil)
   (inners    :initform nil)))

(defun make-specifier (name construct const typeof modifier const-ptr array-def default attrs &optional (anonymous nil))
  (let ((instance (make-instance 'specifier
				 :name name
				 :construct construct
				 :const const
				 :typeof typeof
				 :modifier modifier
				 :const-ptr const-ptr
				 :array-def array-def
				 :default default
				 :attrs attrs
				 :anonymous anonymous)))
    (cond ((eql construct '|@FUNCTION|)
	   (setf (slot-value instance 'params) (make-hash-table :test 'equal)))
	  ((eql construct '|@ENUM|)
 	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  ((eql construct '|@STRUCT|)
	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  ((eql construct '|@UNION|)
	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  ((eql construct '|@CLASS|)
	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  ((eql construct '|@GUARD|)
	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  ((eql construct '|@TARGET|)
	   (setf (slot-value instance 'inners) (make-hash-table :test 'equal)))
	  (t t))
    instance))

(defmethod spec-param ((spec specifier) (alias symbol) (param-spec specifier))
  (setf (gethash alias (slot-value spec 'params)) param-spec))

(defmethod spec-inner ((spec specifier) (alias symbol) (inner-spec specifier))
  (setf (gethash alias (slot-value spec 'inners)) inner-spec))

(defmethod spec-inner ((spec specifier) (alias list) (inner-spec specifier))
  (setf (gethash alias (slot-value spec 'inners)) inner-spec))

(defmethod spec-method ((spec specifier) (alias symbol) (method-spec specifier))
  (if (and (key-eq alias '|main|) (find '|static| (attrs method-spec)))
      (if (not (gethash alias (slot-value spec 'inners) nil))
	  (push method-spec (gethash alias (slot-value spec 'inners)))
	(error (format nil "only one static main allowed ~A" alias)))
    (if (key-eq alias '|__dtor__|)
	(push method-spec (gethash alias (slot-value spec 'inners)))
      (progn
	(setf (name method-spec)
	      (user-symbol (format nil "~A_~A" alias (length (gethash alias (slot-value spec 'inners))))))
	(push method-spec (gethash alias (slot-value spec 'inners)))))))

(defun dump-specifier (spec)
  (list
   (name      spec)
   (construct spec)
   (const     spec)
   (typeof    spec)
   (modifier  spec)
   (const-ptr spec)
   (array-def spec)
   (default   spec)
   (attrs     spec)
   (anonymous spec)
   nil
   (unless (null (slot-value spec 'params))
     (let ((buffer '()))
       (maphash #'(lambda(key value)
		    (push (dump-specifier value) buffer))
		(slot-value spec 'params))
       (reverse buffer)))
   (unless (null (slot-value spec 'inners))
     (let ((buffer '()))
       (maphash #'(lambda(key value)
		    (if (listp value)
			(let ((method-buffer '()))
			  (dolist (method value)
			    (push (dump-specifier method) method-buffer))
			  (push (list key method-buffer) buffer))
		      (push (dump-specifier value) buffer)))
		(slot-value spec 'inners))
       (reverse buffer)))))

(defun load-specifier (meta)
  (let* ((name      (nth 0  meta))
	 (construct (nth 1  meta))
	 (const     (nth 2  meta))
	 (typeof    (nth 3  meta))
	 (modifier  (nth 4  meta))
	 (const-ptr (nth 5  meta))
	 (array-def (nth 6  meta))
	 (default   (nth 7  meta))
	 (attrs     (nth 8  meta))
	 (anonymous (nth 9  meta))
	 (params-l  (nth 11 meta))
	 (inners-l  (nth 12 meta))
	 (params    (unless (null params-l) (make-hash-table :test 'equal)))
	 (inners    (unless (null inners-l) (make-hash-table :test 'equal))))
    (unless (null params-l)
      (dolist (param params-l)
	(setf (gethash (car param) params) (load-specifier param))))
    (unless (null inners-l)
      (dolist (inner inners-l)
	(if (= (length inner) 2)
	    (let ((buffer '()))
	      (dolist (method (nth 1 inner))
		(push (load-specifier method) buffer))
	      (setf (gethash (car inner) inners) buffer))
	  (setf (gethash (car inner) inners) (load-specifier inner)))))
    (let ((spec (make-specifier name construct const typeof modifier const-ptr
				array-def default attrs anonymous)))
      (setf (slot-value spec 'params) params)
      (setf (slot-value spec 'inners) inners)
      spec)))

(defun copy-specifier (spec)
  (make-specifier (name spec) (construct spec) (const spec) (typeof spec)
		  (modifier spec) (const-ptr spec) (array-def spec) (default spec)
		  (attrs spec) (anonymous spec)))

(defun copy-specifiers (table)
  (let ((new-table (make-hash-table
                    :test (hash-table-test table)
                    :size (hash-table-size table)
		    :rehash-size (hash-table-rehash-size table)
		    :rehash-threshold (hash-table-rehash-threshold table))))
    (maphash #'(lambda(key value)
                 (setf (gethash key new-table) value))
             table)
    new-table))

(defun print-specifier (spec &optional (lvl 0) &key (recursive t))
  (format t
    "~A~A ~S ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~S ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]~%"
	  (indent lvl) (construct spec) (name spec) (null (const spec)) (const spec) (null (typeof spec)) (typeof spec)
	  (null (modifier spec)) (modifier spec) (null (const-ptr spec)) (const-ptr spec)
	  (null (array-def spec)) (array-def spec) (null (default spec)) (default spec)
	  (null (attrs spec)) (attrs spec) (anonymous spec))
  (when recursive
    (let ((params (slot-value spec 'params))
	  (inners (slot-value spec 'inners)))
      (when params (print-specifiers params (+ 1 lvl) :with-key nil))
      (when inners (print-specifiers inners (+ 1 lvl) :with-key nil)))))

(defun print-specifiers (table &optional (lvl 0) &key (with-key t))
  (maphash #'(lambda (k v)
	       (when with-key (format t "~S: " k))
	       (if (listp v)
		   (dolist (c v)
		     (print-specifier c lvl :recursive nil))
		 (print-specifier v lvl :recursive nil)))
	   table))

(defun specify-name< (name)
  (if (is-name name) (user-symbol (symbol-name name))
    (error (format nil "wrong name ~S" name))))

(defun specify-type-name< (name)
  (cond ((key-eq name '|uchar|) "unsigned char")
	((key-eq name '|ushort|) "unsigned short")
	((key-eq name '|uint|) "unsigned int")
	((key-eq name '|ulong|) "unsigned long")
	((key-eq name '|llong|) "long long")
	((key-eq name '|ullong|) "unsigned long long")
	((key-eq name '|i8|) "int8_t")
	((key-eq name '|u8|) "uint8_t")
	((key-eq name '|i16|) "int16_t")
	((key-eq name '|u16|) "uint16_t")
	((key-eq name '|i32|) "int32_t")
	((key-eq name '|u32|) "uint32_t")
	((key-eq name '|i64|) "int64_t")
	((key-eq name '|u64|) "uint64_t")
	((key-eq name '|i128|) "__int128")
	((key-eq name '|u128|) "unsigned __int128")
	((key-eq name '|real|) "long double")
	(t (specify-name< name))))

(defun specify-type< (desc ir)
  (unless (listp desc) (error (format nil "wrong type descriptor ~D ~A. missing () around type?" -1 desc)))
  (let ((len (length desc))
	(const nil)
	(type nil)
	(modifier nil)
	(const-ptr nil)
	(variable nil)
	(array nil)
	(status 0))
    (cond ((symbolp desc) (setq type desc))
	  ((= len 1) (setq type (nth 0 desc)))
	  ((= len 2) (if (key-eq (nth 0 desc) '|const|)
			 (progn
			   (setq const (nth 0 desc))
			   (setq type (nth 1 desc)))
		       (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			   (progn
			     (setq type (nth 0 desc))
			     (setq modifier (nth 1 desc)))
			 (if (is-array (nth 1 desc))
			     (progn
			       (setq type (nth 0 desc))
			       (setq array (nth 1 desc)))
			   (progn
			     (setq type (nth 0 desc))
			     (setq variable (nth 1 desc)))))))
	  ((= len 3) (if (key-eq (nth 0 desc) '|const|)
			 (if (find (nth 2 desc) *modifiers* :test #'key-eq) 
			     (progn
			       (setq const (nth 0 desc))
			       (setq type (nth 1 desc))
			       (setq modifier (nth 2 desc)))
			   (if (is-array (nth 2 desc))
			       (progn
				 (setq const (nth 0 desc))
				 (setq type (nth 1 desc))
				 (setq array (nth 2 desc)))
			     (progn
			       (setq const (nth 0 desc))
			       (setq type (nth 1 desc))
			       (setq variable (nth 2 desc)))))
		       (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			   (if (key-eq (nth 2 desc) '|const|)
			       (progn
				 (setq type (nth 0 desc))
				 (setq modifier (nth 1 desc))
				 (setq const-ptr (nth 2 desc)))
			     (if (is-array (nth 2 desc))
				 (progn
				   (setq type (nth 0 desc))
				   (setq modifier (nth 1 desc))
				   (setq array (nth 2 desc)))
			       (progn
				 (setq type (nth 0 desc))
				 (setq modifier (nth 1 desc))
				 (setq variable (nth 2 desc)))))
			 (progn
			   (setq type (nth 0 desc))
			   (setq variable (nth 1 desc))
			   (setq array (nth 2 desc))))))
	  ((= len 4) (if (key-eq (nth 0 desc) '|const|)
			 (if (find (nth 2 desc) *modifiers* :test #'key-eq)
			     (if (key-eq (nth 3 desc) '|const|)
				 (progn
				   (setq const (nth 0 desc))
				   (setq type (nth 1 desc))
				   (setq modifier (nth 2 desc))
				   (setq const-ptr (nth 3 desc)))
			       (if (is-array (nth 3 desc))
				   (progn
				     (setq const (nth 0 desc))
				     (setq type (nth 1 desc))
				     (setq modifier (nth 2 desc))
				     (setq array (nth 3 desc)))
				 (progn
				   (setq const (nth 0 desc))
				   (setq type (nth 1 desc))
				   (setq modifier (nth 2 desc))
				   (setq variable (nth 3 desc)))))
			   (progn
			     (setq const (nth 0 desc))
			     (setq type (nth 1 desc))
			     (setq variable (nth 2 desc))
			     (setq array (nth 3 desc))))
		       (if (key-eq (nth 2 desc) '|const|)
			   (if (is-array (nth 3 desc))
			       (progn
				 (setq type (nth 0 desc))
				 (setq modifier (nth 1 desc))
				 (setq const-ptr (nth 2 desc))
				 (setq array (nth 3 desc)))
			     (progn
			       (setq type (nth 0 desc))
			       (setq modifier (nth 1 desc))
			       (setq const-ptr (nth 2 desc))
			       (setq variable (nth 3 desc))))
			 (progn
			   (setq type (nth 0 desc))
			   (setq modifier (nth 1 desc))
			   (setq variable (nth 2 desc))
			   (setq array (nth 3 desc))))))
	  ((= len 5) (if (is-array (nth 4 desc))
			 (progn
			   (setq const (nth 0 desc))
			   (setq type (nth 1 desc))
			   (setq modifier (nth 2 desc))
			   (setq const-ptr (nth 3 desc))
			   (setq array (nth 4 desc)))
		       (progn
			 (setq const (nth 0 desc))
			 (setq type (nth 1 desc))
			 (setq modifier (nth 2 desc))
			 (setq const-ptr (nth 3 desc))
			 (setq variable (nth 4 desc)))))
	  ((= len 6) (progn
		       (setq const (nth 0 desc))
		       (setq type (nth 1 desc))
		       (setq modifier (nth 2 desc))
		       (setq const-ptr (nth 3 desc))
		       (setq variable (nth 4 desc))
		       (setq array (nth 5 desc))))
	  (t (setq status -2)))
    (unless (or (null const) (key-eq const '|const|)) (setq status -3))
    (unless (or (null modifier) (key-eq modifier '&) (key-eq modifier '*) (key-eq modifier '**)) (setq status -4))
    (unless (or (null const-ptr) (key-eq const-ptr '|const|)) (setq status -5))
    (unless (or (null const-ptr) (key-eq modifier '*) (key-eq modifier '**)) (setq status -6))
    (when  (and (not (null array)) (key-eq modifier '**)) (setq status -7))
    (unless (or (null array) (is-array array)) (setq status -8))
    (when (< status 0) (error (format nil "wrong type descriptor ~D ~A" status desc)))
    (values const type modifier const-ptr (specify-name< variable) array)))

(defun specify-type-value< (desc ir)
  (unless (listp desc) (error (format nil "wrong type descriptor ~D ~A. missing () around type?" -1 desc)))
  (let ((l (cdr (last desc)))
	(wl (without-last desc)))
    (if (and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'FUNCTION))
	(progn (setq l (nth (- (length desc) 1) desc))
	       (multiple-value-bind (const type modifier const-ptr variable array)
		 (specify-type< (without-last wl) ir)
		 (values const type modifier const-ptr variable array l)))
      (if (and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'QUOTE))
	  (progn (setq l (nthcdr (- (length desc) 2) desc))
		 (multiple-value-bind (const type modifier const-ptr variable array)
		   (specify-type< (without-last wl) ir)
		   (values const type modifier const-ptr variable array l)))
	(if (listp l)
	    (specify-type< desc ir)
	  (multiple-value-bind (const type modifier const-ptr variable array)
	    (specify-type< wl ir)
	    (values const type modifier const-ptr variable array l)))))))

(defun specify-type-value<dep (desc ir)
  (unless (listp desc) (error (format nil "wrong type descriptor ~D ~A. missing () around type?" -1 desc)))
  (let ((l (cdr (last desc)))
	(wl (without-last desc)))
    (if (and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'FUNCTION))
	(progn (setq l (nth (- (length desc) 1) desc))
	       (multiple-value-bind (const type modifier const-ptr variable array)
		 (specify-type< (without-last wl) ir)
		 (values const type modifier const-ptr variable array l)))
      (if (and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'QUOTE))
	  (progn (setq l (nthcdr (- (length desc) 2) desc))
		 (multiple-value-bind (const type modifier const-ptr variable array)
		   (specify-type< (without-last wl) ir)
		   (values const type modifier const-ptr variable array l)))
	(if (listp l)
	    (specify-type< desc ir)
	  (multiple-value-bind (const type modifier const-ptr variable array)
	    (specify-type< wl ir)
	    (values const type modifier const-ptr variable array l)))))))
	  
(defun specify-preprocessor (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong preprocessor attributes ~A" attrs)))
  (when (> (length def) 2) (error (format nil "wrong preprocessor definition ~A" def)))
  (let* ((name (gensym "lcc#PREPROC"))
	 (preproc-specifier (make-specifier name '|@PREPROC| nil nil nil nil nil nil nil)))
    (spec-inner ir name preproc-specifier)
    (setf (slot-value preproc-specifier 'body) def)))

(defun specify-include (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong include attributes ~A" attrs)))
  (let ((heads (nth 1 def)))
    (if (listp heads)
	(if (and (stringp (car (last heads))) (every #'symbolp (butlast heads)))
	    (spec-inner ir heads (make-specifier heads '|@INCLUDE| nil nil nil nil nil nil nil))
	  (error (format nil "wrong inclusion ~S" def)))
      (if (symbolp heads)
	  (spec-inner ir heads (make-specifier heads '|@INCLUDE| nil nil nil nil nil nil nil))
	(error (format nil "wrong inclusion ~S" def))))))

(defun specify-import (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong import attributes ~A" attrs)))
  (let* ((heads (nth 1 def))
	 (args  (nthcdr 2 def))
	 (abbr  heads))
    (dotimes (i (length args))
      (when (zerop (mod i 2))
	(when (key-eq (nth i args) ':|as|)
	  (setq abbr (nth (+ i 1) args)))))
    (if (and (or (stringp (car (last heads))) (symbolp (car (last heads)))) (every #'symbolp (butlast heads)))
	(spec-inner ir abbr (make-specifier abbr '|@IMPORT| nil nil nil nil nil heads nil))
      (error (format nil "wrong import ~S" def)))))

(defun specify-typedef (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 3) (error (format nil "syntax error ~A" def)))
  (multiple-value-bind (const type modifier const-ptr variable array) (specify-type< (nthcdr 1 def) ir)
		       (when (null variable) (error (format nil "syntax error ~A" def)))
		       (spec-inner ir variable (make-specifier variable '|@TYPEDEF| const type
							      modifier const-ptr array nil nil))))

(defun specify-variable (def attrs lvl ir &optional memberof)
  (let* ((is-auto     nil)
	 (is-register nil)
	 (is-static   nil)
	 (is-extern   nil)
	 (type-desc (cadr def)))
    (dolist (attr attrs)
      (let ((name (car attr)))
	(cond ((key-eq name '|auto|)     (setq is-auto t))
	      ((key-eq name '|register|) (setq is-register t))
	      ((key-eq name '|static|)   (setq is-static t))
	      ((key-eq name '|extern|)   (setq is-extern t))
	      (t (error (format nil "unknown variable attribute ~A" attr))))))
    (multiple-value-bind (const type modifier const-ptr variable array default)
      (specify-type-value< type-desc ir)
      (when (and (not (null memberof)) (or (not (null const)) (not (null const-ptr))))
	(error (format nil "members could not be const or const pointer ~A" type-desc)))
      (let ((attributes '()))
	(when is-extern   (push '|extern|   attributes))
	(when is-static   (push '|static|   attributes))
	(when is-register (push '|register| attributes))
	(when is-auto     (push '|auto|     attributes))
	(spec-inner ir variable (make-specifier variable '|@VARIABLE| const type
					       modifier const-ptr array default attributes)))
      (let ((args (cddr def)))
	(unless (zerop (mod (length args) 2)) (error (format nil "wrong member features ~A" type-desc)))
	(dotimes (i (length args))
	  (when (zerop (mod i 2))
	    (progn
	      (when (key-eq (nth i args) ':|reader|)
		(let ((custom (specify-name< (nth (+ i 1) args))))
		  (unless (null array)
		    (if (null modifier)
			(setq modifier (user-symbol "*"))
		      (if (key-eq '|*| modifier)
			  (setq modifier (user-symbol "**")))))
		  (let ((reader-specifier (make-specifier custom '|@FUNCTION| (if (null modifier) nil (user-symbol "const"))
							  type modifier nil nil nil nil)))
		    (spec-method ir custom reader-specifier)
		    (setf (slot-value reader-specifier 'body) (user-symbol (format nil "((return (-> this ~A)))" variable))))))
	      (when (key-eq (nth i args) ':|writer|)
		(let ((custom (specify-name< (nth (+ i 1) args))))
		  (unless (null array)
		    (if (null modifier)
			(setq modifier (user-symbol "*"))
		      (if (key-eq '|*| modifier)
			  (setq modifier (user-symbol "**")))))
		  (let ((writer-specifier (make-specifier custom '|@FUNCTION| nil (user-symbol "void") nil nil nil nil nil))
			(param-name (user-symbol (symbol-name (gensym "PARAM")))))
		    (spec-method ir custom writer-specifier)
		    (spec-param writer-specifier param-name
			       (make-specifier param-name '|@PARAMETER| (if (null modifier) nil (user-symbol "const"))
					       type modifier nil nil nil nil))
		    (setf (slot-value writer-specifier 'body)
			  (user-symbol (format nil "((set (-> this ~A) ~A))" variable param-name))))))
	      )))))))

(defun specify-function (def attrs lvl ir &optional methodof &key (method-type :method))
  (let* ((is-static   nil)
	 (is-declare  nil)
	 (is-inline   nil)
	 (is-extern   nil)
	 (is-override nil)
	 (name (specify-name< (nth 1 def)))
	 (params (nth 2 def))
	 (r-> (nth 3 def))
	 (has-returns (and (consp r->) (key-eq (car r->) '|returns|)))
	 (returns (if has-returns r->
		    (if (key-eq name '|main|)
			(user-symbol "(returns int)")
		      (user-symbol "(returns void)"))))
	 (body (if has-returns (nthcdr 4 def) (nthcdr 3 def))))
    (when (and (eql method-type :ctor) has-returns)
      (error (format nil "constructor with returns form ~A" returns)))
    (when (and (eql method-type :dtor) has-returns)
      (error (format nil "destructor with returns form ~A" returns)))
    (when (and (not (null methodof)) (eql method-type :ctor))
      (setq returns (user-symbol (format nil "(returns ~A)" (default methodof)))))
    (dolist (attr attrs)
      (let ((name (car attr)))
	(cond ((key-eq name '|static|)    (setq is-static t))
	      ((key-eq name '|declare|)   (setq is-declare t))
	      ((key-eq name '|inline|)    (setq is-inline t))
	      ((key-eq name '|extern|)    (setq is-extern t))
	      ((key-eq name '|override|)  (setq is-override t))
	      (t (error (format nil "unknown function attribute ~A" attr))))))
    (when (and (not (null methodof)) (eql method-type :ctor) is-static)
      (error (format nil "static constructor is not allowed ~A" def)))
    (when (< (length def) 3) (error (format nil "wrong function definition ~A" def)))
    (when (and is-declare body) (error (format nil "function declaration with body '~A' ~A" name (first body))))
    (let ((function-specifier nil))
      (let ((attributes '()))
	(when is-extern   (push '|extern|   attributes))
	(when is-inline   (push '|inline|   attributes))
	(when is-static   (push '|static|   attributes))
	(when is-declare  (push '|declare|  attributes))
	(when is-override (push '|override| attributes))
	(multiple-value-bind (const type modifier const-ptr variable array)
	  (specify-type< (cdr returns) ir)
	  (setq function-specifier (make-specifier name '|@FUNCTION| const type modifier
						   const-ptr array nil attributes))
	  (if (null methodof)
	      (spec-inner ir name function-specifier)
	    (spec-method ir name function-specifier))))
      (unless (null methodof)
	      (when (eql method-type :ctor) (setf (default function-specifier) :ctor))
	      (when (eql method-type :dtor) (setf (default function-specifier) :dtor)))
      (setf (slot-value function-specifier 'body) body)
      (dolist (param params)
        (if (equal param (list (user-symbol "***")))
	    (spec-param function-specifier (user-symbol "***")
			  (make-specifier (user-symbol "***") '@|PARAMETER| nil nil nil nil nil nil nil))
	  (let ((is-anonymous nil))
	    (multiple-value-bind (const type modifier const-ptr variable array default)
	      (specify-type-value< param ir)
	      (when (null variable)
		(setq is-anonymous t)
		(setq variable (gensym "lcc#PARAM")))
	      (spec-param function-specifier variable
			  (make-specifier variable '@|PARAMETER| const type modifier
					  const-ptr array default nil is-anonymous)))))))))

(defun specify-enum (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	 (name (if is-anonymous (gensym "lcc#ENUM") (specify-name< (nth 1 def))))
	 (constants (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	 (enum-specifier (make-specifier name '|@ENUM| nil nil nil nil nil nil nil)))
    (spec-inner ir name enum-specifier)
    (setf (anonymous enum-specifier) is-anonymous)
    (loop for const in constants
	  with l = (length constants)
	  for i from 0 to l
	  do (progn
	       (unless (and (consp const) (symbolp (car const))) (error (format nil "syntax error ~A" const)))
	       (let ((key (car const))
		     (value (cdr const)))
		 (unless (or (null value) (numberp value) (symbolp value)) (error (format nil "syntax error ~A" const)))
		 (spec-inner enum-specifier key (make-specifier key '|@VARIABLE| nil nil nil nil nil value nil)))))))

(defun specify-struct (def attrs lvl ir &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	 (name (if is-anonymous (gensym "lcc#STRUCT") (specify-name< (nth 1 def))))
	 (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	 (struct-specifier (make-specifier name '|@STRUCT| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested structs could be anonymous")))
    (spec-inner ir name struct-specifier)
    (setf (anonymous struct-specifier) is-anonymous)
    (let ((attributes '())
	  (declares '()))
      (dolist (clause clauses)
	(if (consp clause)
	    (let ((construct (car clause)))
	      (cond ((find (char (symbol-name construct) 0) "@#")
		     (specify-preprocessor clause attributes 0 struct-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|static|)   (push clause attributes))
		    ((key-eq construct '|declare|)  (push clause attributes))
		    ((key-eq construct '|inline|)   (push clause attributes))
		    ((key-eq construct '|auto|)     (push clause attributes))
		    ((key-eq construct '|register|) (push clause attributes))
		    ((key-eq construct '|extern|)   (push clause attributes))
		    ((key-eq construct '|member|)
		     (specify-variable clause attributes (+ lvl 1) struct-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|method|)
		     (specify-function clause attributes (+ lvl 1) struct-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|enum|)
		     (specify-enum     clause attributes (+ lvl 1) struct-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|struct|)
		     (specify-struct   clause attributes (+ lvl 1) struct-specifier :nested t)
		     (setq attributes '()))
		    ((key-eq construct '|union|)
		     (specify-union    clause attributes (+ lvl 1) struct-specifier :nested t)
		     (setq attributes '()))
		    ((key-eq construct '|declares|)
		     (when (= (length clause) 1)
		       (error (format nil "declares needs a name of variable for anonymous struct")))
		     (when (> (length clause) 2)
		       (error (format nil "declares clause only accepts a name of variable ~A" (nth 1 clause))))
		     (push (nth 1 clause) declares))
		    (t (error (format nil "unknown clause ~A in struct ~A" construct name)))))
	  (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	(error (format nil "declares must be inside anonymous struct ~A" name)))
      (dolist (decl declares)
	(spec-inner struct-specifier decl (make-specifier decl '|@DECLARES| nil name nil nil nil nil nil))))))

(defun specify-union (def attrs lvl ir &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	 (name (if is-anonymous (gensym "lcc#UNION") (specify-name< (nth 1 def))))
	 (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	 (union-specifier (make-specifier name '|@UNION| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested unions could be anonymous")))
    (spec-inner ir name union-specifier)
    (setf (anonymous union-specifier) is-anonymous)
    (let ((attributes '())
	  (declares '()))
      (dolist (clause clauses)
	(if (consp clause)
	    (let ((construct (car clause)))
	      (cond ((find (char (symbol-name construct) 0) "@#")
		     (specify-preprocessor clause attributes 0 union-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|member|)
		     (specify-variable clause attributes (+ lvl 1) union-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|struct|)
		     (specify-struct   clause attributes (+ lvl 1) union-specifier :nested t)
		     (setq attributes '()))
		    ((key-eq construct '|union|)
		     (specify-union    clause attributes (+ lvl 1) union-specifier :nested t)
		     (setq attributes '()))
		    ((key-eq construct '|declares|)
		     (when (= (length clause) 1)
		       (error (format nil "declares needs a name of variable for anonymous union")))
		     (when (> (length clause) 2)
		       (error (format nil "declares clause only accepts a name of variable ~A" (nth 1 clause))))
		     (push (nth 1 clause) declares))
		    (t (error (format nil "unknown clause ~A in union ~A" construct name)))))
	  (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	(error (format nil "declares must be inside anonymous union ~A" name)))
      (dolist (decl declares)
        (spec-inner union-specifier decl (make-specifier decl '|@DECLARES| nil name nil nil nil nil nil))))))

(defun specify-guard (def attrs lvl ir)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((name (specify-name< (nth 1 def)))
	 (clauses (nthcdr 2 def))
	 (guard-specifier (make-specifier name '|@GUARD| nil nil nil nil nil nil nil)))
    (spec-inner ir name guard-specifier)
    (let ((attributes '()))
      (dolist (clause clauses)
	(if (consp clause)
	    (let ((construct (car clause)))
	      (cond ((find (char (symbol-name construct) 0) "@#")
		     (specify-preprocessor clause attributes 0 guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|static|)   (push clause attributes))
		    ((key-eq construct '|declare|)  (push clause attributes))
		    ((key-eq construct '|inline|)   (push clause attributes))
		    ((key-eq construct '|auto|)     (push clause attributes))
		    ((key-eq construct '|register|) (push clause attributes))
		    ((key-eq construct '|extern|)   (push clause attributes))
		    ((key-eq construct '|include|)  (setq attributes '()))
		    ((key-eq construct '|guard|)
		     (specify-guard    clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|variable|)
		     (specify-variable clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|function|)
		     (specify-function clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|enum|)
		     (specify-enum     clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|struct|)
		     (specify-struct   clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|union|)
		     (specify-union    clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    ((key-eq construct '|typedef|)
		     (specify-typedef  clause attributes lvl guard-specifier)
		     (setq attributes '()))
		    (t (error (format nil "unknown clause ~A in guard ~A" construct name)))))
	  (error (format nil "syntax error ~A" clause)))))))
